import { Runtime, DefaultLogger, Worker, InjectedSinks } from '@temporalio/worker';
import { LoggerSinks } from './workflows/logger';
import * as activities from './activities';
import { ActivityInboundLogInterceptor } from './activities/interceptors';
import { createLogger } from './logging';

const logger = createLogger({
  isProduction: process.env.NODE_ENV === 'production',
  logFilePath: process.env.WORKER_LOG_PATH || '/var/log/worker.log',
});

async function main() {
  // Create loggers with different labels for the separate components
  const workerLogger = logger.child({ label: 'worker' });
  const workflowLogger = logger.child({ label: 'workflow' });
  const activityLogger = logger.child({ label: 'activity' });

  // @@@SNIPSTART typescript-core-telemetry-options
  // Configure Rust Core runtime to export SDK logs, metrics and (optionally) internal traces
  Runtime.install({
    // Install a logger to collect logs generated by Node.js Workers and Rust Core.
    logger: new DefaultLogger('DEBUG', (entry) => {
      workerLogger.log({
        level: entry.level.toLowerCase(),
        message: entry.message,
        timestamp: Number(entry.timestampNanos / 1_000_000n),
        ...entry.meta,
      });
    }),
    // Telemetry options control how logs, metrics and traces are exported out of Rust Core
    telemetryOptions: {
      // To export metrics and traces using the OpenTelemetry Collector, use `oTelCollectorUrl`.
      // see https://opentelemetry.io/docs/collector/getting-started/ for more information.
      //
      // To expose a port for Prometheus to collect metrics from Core, use `prometheusMetricsBindAddress`
      // You can verify metrics are exported with `curl -fail localhost:9464/metrics`
      prometheusMetricsBindAddress: '0.0.0.0:9464',
      // A string in the env filter format specified here:
      // https://docs.rs/tracing-subscriber/0.2.20/tracing_subscriber/struct.EnvFilter.html
      //
      // Which determines what tracing data is collected in the Core SDK
      tracingFilter: 'temporal_sdk_core=DEBUG',
      // What level, if any, logs should be forwarded from Rust Core to the Node.js logger
      logForwardingLevel: 'DEBUG',
    },
  });
  // @@@SNIPEND

  // The Worker side of our logger sinks, forwards logs from Workflows to a Winston logger
  const sinks: InjectedSinks<LoggerSinks> = {
    logger: {
      debug: {
        fn(workflowInfo, message, meta) {
          workflowLogger.child(workflowInfo).debug(message, meta);
        },
      },
      info: {
        fn(workflowInfo, message, meta) {
          workflowLogger.child(workflowInfo).info(message, meta);
        },
      },
      error: {
        fn(workflowInfo, message, meta) {
          workflowLogger.child(workflowInfo).error(message, meta);
        },
      },
      warn: {
        fn(workflowInfo, message, meta) {
          workflowLogger.child(workflowInfo).warn(message, meta);
        },
      },
    },
  };

  // @@@SNIPSTART typescript-worker-full-logging-setup
  // Create a worker that uses the Runtime instance installed above
  const worker = await Worker.create({
    workflowsPath: require.resolve('./workflows'),
    activities,
    taskQueue: 'instrumentation',
    // Install interceptors
    interceptors: {
      activityInbound: [(ctx) => new ActivityInboundLogInterceptor(ctx, activityLogger)],
      workflowModules: [require.resolve('./workflows/interceptors')],
    },
    // Inject sinks
    sinks,
  });
  // @@@SNIPEND
  await worker.run();
}

main().then(
  () => void process.exit(0),
  (err) => {
    logger.error('Process failed', err);
    process.exit(1);
  }
);
